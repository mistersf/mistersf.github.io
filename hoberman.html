<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Robust Hoberman Simulator</title>
    <style>
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
        background-color: #111827;
        color: #f3f4f6;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100vh;
        margin: 0;
        overflow: hidden;
      }

      .container {
        position: relative;
        background: #1f2937;
        padding: 20px;
        border-radius: 16px;
        box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.5);
        text-align: center;
      }

      canvas {
        background: #000;
        border-radius: 8px;
        border: 1px solid #374151;
        cursor: grab;
      }
      canvas:active {
        cursor: grabbing;
      }

      .controls {
        margin-top: 20px;
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        text-align: left;
      }

      .control-group {
        display: flex;
        flex-direction: column;
        gap: 5px;
      }

      .control-row {
        display: flex;
        gap: 8px;
        align-items: center;
      }

      .control-row input[type="number"] {
        width: 72px;
        padding: 4px 6px;
        border-radius: 6px;
        border: 1px solid #374151;
        background: #0b1220;
        color: #f3f4f6;
      }

      label {
        font-size: 0.85rem;
        color: #9ca3af;
        text-transform: uppercase;
        letter-spacing: 0.05em;
      }

      input[type="range"] {
        width: 100%;
        cursor: pointer;
        accent-color: #3b82f6;
      }

      .header {
        margin-bottom: 15px;
      }
      h2 {
        margin: 0;
        font-size: 1.25rem;
      }
      p {
        margin: 5px 0 0;
        color: #6b7280;
        font-size: 0.8rem;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h2>Hoberman Mechanism</h2>
        <p>Drag slider or canvas to expand/contract</p>
      </div>

      <canvas id="canvas" width="500" height="500"></canvas>

      <div class="controls">
        <div class="control-group">
          <label>Expansion</label>
          <div class="control-row">
            <input type="range" id="radiusInput" min="0" max="100" value="50" />
            <input
              type="number"
              id="radiusNumber"
              min="0"
              max="100"
              step="1"
              value="50"
            />
          </div>
        </div>
        <div class="control-group">
          <label>Segments (N)</label>
          <div class="control-row">
            <input
              type="range"
              id="segInput"
              min="4"
              max="24"
              value="8"
              step="2"
            />
            <input
              type="number"
              id="segNumber"
              min="4"
              max="24"
              step="2"
              value="8"
            />
          </div>
        </div>
        <div class="control-group">
          <label>Zoom</label>
          <div class="control-row">
            <input
              type="range"
              id="zoomInput"
              min="0.5"
              max="2"
              value="1"
              step="0.01"
            />
            <input
              type="number"
              id="zoomNumber"
              min="0.5"
              max="2"
              step="0.01"
              value="1"
            />
          </div>
        </div>
        <div class="control-group">
          <label>Outer Arm Length</label>
          <div class="control-row">
            <input
              type="range"
              id="outerArmInput"
              min="40"
              max="200"
              value="120"
              step="1"
            />
            <input
              type="number"
              id="outerArmNumber"
              min="40"
              max="200"
              step="1"
              value="120"
            />
          </div>
        </div>
        <div class="control-group">
          <label>Inner Arm Length</label>
          <div class="control-row">
            <input
              type="range"
              id="innerArmInput"
              min="20"
              max="180"
              value="80"
              step="1"
            />
            <input
              type="number"
              id="innerArmNumber"
              min="20"
              max="180"
              step="1"
              value="80"
            />
          </div>
        </div>
        <div class="control-group">
          <label>Outer / Inner Ratio</label>
          <div class="control-row">
            <input
              type="range"
              id="ratioInput"
              min="0.25"
              max="3"
              value="1.5"
              step="0.01"
            />
            <input
              type="number"
              id="ratioNumber"
              min="0.25"
              max="3"
              value="1.5"
            />
          </div>
        </div>
      </div>
    </div>

    <script>
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      const radiusSlider = document.getElementById("radiusInput");
      const segSlider = document.getElementById("segInput");
      const zoomSlider = document.getElementById("zoomInput");
      const outerArmSlider = document.getElementById("outerArmInput");
      const innerArmSlider = document.getElementById("innerArmInput");
      const radiusNumber = document.getElementById("radiusNumber");
      const segNumber = document.getElementById("segNumber");
      const zoomNumber = document.getElementById("zoomNumber");
      const outerArmNumber = document.getElementById("outerArmNumber");
      const innerArmNumber = document.getElementById("innerArmNumber");
      const ratioSlider = document.getElementById("ratioInput");
      const ratioNumber = document.getElementById("ratioNumber");

      // Config defaults
      const DEFAULT_OUTER_ARM = 120; // outer arm length (pixels)
      const DEFAULT_INNER_ARM = 80; // inner arm length (pixels)

      let state = {
        segments: 8,
        expansion: 0.5, // 0.0 to 1.0
        zoom: 1.0,
        outerArm: DEFAULT_OUTER_ARM,
        innerArm: DEFAULT_INNER_ARM,
      };

      // Helper: Find intersection of two circles
      // Used to find where the arm tips MUST be to connect adjacent pivots
      function getIntersection(x1, y1, r1, x2, y2, r2, side) {
        const d2 = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
        const d = Math.sqrt(d2);

        // Circles too far apart or contained within each other
        if (d > r1 + r2 || d < Math.abs(r1 - r2) || d === 0) return null;

        const a = (r1 * r1 - r2 * r2 + d2) / (2 * d);
        const h = Math.sqrt(Math.max(0, r1 * r1 - a * a));

        const x2_part = x2 - x1;
        const y2_part = y2 - y1;

        const x0 = x1 + (a * x2_part) / d;
        const y0 = y1 + (a * y2_part) / d;

        const rx = -y2_part * (h / d);
        const ry = x2_part * (h / d);

        // "side" determines which of the two intersection points we pick (inner or outer)
        if (side > 0) {
          return { x: x0 + rx, y: y0 + ry };
        } else {
          return { x: x0 - rx, y: y0 - ry };
        }
      }

      function draw() {
        // Reset transform and clear full canvas (unscaled)
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Apply zoom scale for subsequent drawing
        ctx.setTransform(state.zoom, 0, 0, state.zoom, 0, 0);

        const N = state.segments;

        // Center in logical (pre-scale) coordinates so scaling keeps it centered on canvas
        const CX = canvas.width / (2 * state.zoom);
        const CY = canvas.height / (2 * state.zoom);

        // 1. Calculate Pivot Radius based on expansion state
        // We limit the Max Radius so the pivots don't go further apart than 2*maxArm
        // (If pivots are too far apart, the arms can't touch)
        const angleStep = (Math.PI * 2) / N;
        const maxArm = Math.max(state.outerArm, state.innerArm);
        const maxChord = maxArm * 1.95; // slightly less than 2*L to prevent locking
        // chord = 2 * R * sin(pi/N) => MaxR = maxChord / (2*sin(pi/N))
        const maxR = maxChord / (2 * Math.sin(Math.PI / N));
        const minR = 20;

        const currentR = minR + state.expansion * (maxR - minR);

        // 2. Calculate Pivot Positions
        const pivots = [];
        for (let i = 0; i < N; i++) {
          const theta = i * angleStep;
          pivots.push({
            x: CX + currentR * Math.cos(theta),
            y: CY + currentR * Math.sin(theta),
          });
        }

        // 3. Draw Mechanisms
        ctx.lineWidth = 3;
        ctx.lineJoin = "round";

        for (let i = 0; i < N; i++) {
          const p1 = pivots[i];
          const p2 = pivots[(i + 1) % N]; // Next pivot
          const pPrev = pivots[(i - 1 + N) % N]; // Previous pivot

          // Find OUTER intersection (Tip connecting current and next)
          const outerTip = getIntersection(
            p1.x,
            p1.y,
            state.outerArm,
            p2.x,
            p2.y,
            state.outerArm,
            1
          );

          // Find INNER intersection (Tip connecting current and next)
          // We use -1 to get the point closer to center
          const innerTip = getIntersection(
            p1.x,
            p1.y,
            state.innerArm,
            p2.x,
            p2.y,
            state.innerArm,
            -1
          );

          // If geometry is invalid (e.g. radius too big), skip drawing
          if (!outerTip || !innerTip) continue;

          // DRAWING LOGIC:
          // A Hoberman angulated element is a bent rod.
          // We draw two rods crossing at the pivot P1.

          // Rod A: Connects Inner-Left to Outer-Right
          // But here we just calculate the shared joints.
          // Let's draw the lines from Pivot to the calculated tips.

          // To make it look like "Scissors":
          // We need the tip shared with Next (Right) and Tip shared with Prev (Left).

          const outerRight = outerTip; // Shared with i+1
          const innerRight = innerTip; // Shared with i+1

          // Recalculate intersections with PREVIOUS neighbor for the left side of this pivot
          const outerLeft = getIntersection(
            pPrev.x,
            pPrev.y,
            state.outerArm,
            p1.x,
            p1.y,
            state.outerArm,
            1
          );
          const innerLeft = getIntersection(
            pPrev.x,
            pPrev.y,
            state.innerArm,
            p1.x,
            p1.y,
            state.innerArm,
            -1
          );

          if (outerLeft && innerLeft) {
            // Draw "Angulated Element 1": InnerLeft -> Pivot -> OuterRight
            ctx.strokeStyle = "#3b82f6"; // Blue
            ctx.beginPath();
            ctx.moveTo(innerLeft.x, innerLeft.y);
            ctx.lineTo(p1.x, p1.y);
            ctx.lineTo(outerRight.x, outerRight.y);
            ctx.stroke();

            // Draw "Angulated Element 2": InnerRight -> Pivot -> OuterLeft
            ctx.strokeStyle = "#ef4444"; // Red
            ctx.beginPath();
            ctx.moveTo(innerRight.x, innerRight.y);
            ctx.lineTo(p1.x, p1.y);
            ctx.lineTo(outerLeft.x, outerLeft.y);
            ctx.stroke();
          }

          // Draw Pivot Dot
          ctx.fillStyle = "#fff";
          ctx.beginPath();
          ctx.arc(p1.x, p1.y, 4, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      // Input Handling
      function update() {
        state.expansion = parseFloat(radiusSlider.value) / 100;
        state.segments = parseInt(segSlider.value);
        state.zoom = parseFloat(zoomSlider.value);
        state.outerArm = parseFloat(outerArmSlider.value);
        state.innerArm = parseFloat(innerArmSlider.value);
        // keep ratio in state and sync display
        state.ratio = state.outerArm / state.innerArm;
        // Sync numeric displays
        if (radiusNumber)
          radiusNumber.value = Math.round(state.expansion * 100);
        if (segNumber) segNumber.value = state.segments;
        if (zoomNumber) zoomNumber.value = state.zoom;
        if (outerArmNumber) outerArmNumber.value = state.outerArm;
        if (innerArmNumber) innerArmNumber.value = state.innerArm;
        if (ratioNumber) ratioNumber.value = Number(state.ratio.toFixed(2));
        if (ratioSlider) ratioSlider.value = Number(state.ratio.toFixed(2));

        draw();
      }

      radiusSlider.addEventListener("input", update);
      segSlider.addEventListener("input", update);
      zoomSlider.addEventListener("input", update);
      outerArmSlider.addEventListener("input", update);
      innerArmSlider.addEventListener("input", update);
      if (ratioSlider) {
        ratioSlider.addEventListener("input", (e) => {
          let r = parseFloat(e.target.value);
          if (isNaN(r) || r <= 0) r = state.outerArm / state.innerArm;
          // update innerArm to match desired ratio (keep outerArm constant)
          const newInner = state.outerArm / r;
          // clamp to inner range
          const minInner = parseFloat(innerArmInput.min) || 20;
          const maxInner = parseFloat(innerArmInput.max) || 180;
          const clamped = Math.max(minInner, Math.min(maxInner, newInner));
          innerArmInput.value = clamped;
          if (innerArmNumber) innerArmNumber.value = Math.round(clamped);
          update();
        });
      }

      if (ratioNumber) {
        ratioNumber.addEventListener("change", (e) => {
          let r = parseFloat(e.target.value);
          if (isNaN(r) || r <= 0) return;
          const newInner = state.outerArm / r;
          const minInner = parseFloat(innerArmSlider.min) || 20;
          const maxInner = parseFloat(innerArmSlider.max) || 180;
          const clamped = Math.max(minInner, Math.min(maxInner, newInner));
          innerArmSlider.value = clamped;
          if (innerArmNumber) innerArmNumber.value = Math.round(clamped);
          update();
        });
      }
      // Numeric input -> slider two-way bindings
      if (radiusNumber) {
        radiusNumber.addEventListener("change", (e) => {
          let v = parseFloat(e.target.value);
          if (isNaN(v)) v = 0;
          if (v < 0) v = 0;
          if (v > 100) v = 100;
          radiusSlider.value = v;
          update();
        });
      }

      if (segNumber) {
        segNumber.addEventListener("change", (e) => {
          let v = parseInt(e.target.value) || 4;
          if (v < 4) v = 4;
          if (v > 24) v = 24;
          // enforce even step
          if (v % 2 !== 0) v = v + 1;
          segSlider.value = v;
          update();
        });
      }

      if (zoomNumber) {
        zoomNumber.addEventListener("change", (e) => {
          let v = parseFloat(e.target.value);
          if (isNaN(v)) v = 1;
          if (v < 0.5) v = 0.5;
          if (v > 2) v = 2;
          zoomSlider.value = v;
          update();
        });
      }

      if (outerArmNumber) {
        outerArmNumber.addEventListener("change", (e) => {
          let v = parseFloat(e.target.value) || 40;
          if (v < 40) v = 40;
          if (v > 200) v = 200;
          outerArmSlider.value = v;
          update();
        });
      }

      if (innerArmNumber) {
        innerArmNumber.addEventListener("change", (e) => {
          let v = parseFloat(e.target.value) || 20;
          if (v < 20) v = 20;
          if (v > 180) v = 180;
          innerArmSlider.value = v;
          update();
        });
      }

      // Mouse Drag Interaction
      let isDragging = false;
      canvas.addEventListener("mousedown", () => (isDragging = true));
      window.addEventListener("mouseup", () => (isDragging = false));

      canvas.addEventListener("mousemove", (e) => {
        if (!isDragging) return;
        const rect = canvas.getBoundingClientRect();
        // Convert mouse to logical (pre-scale) coordinates
        const x = (e.clientX - rect.left) / state.zoom;
        const y = (e.clientY - rect.top) / state.zoom;

        // Compute logical center
        const CX = canvas.width / (2 * state.zoom);
        const CY = canvas.height / (2 * state.zoom);

        // Simple distance from center controls expansion
        const dist = Math.sqrt((x - CX) ** 2 + (y - CY) ** 2);
        const maxDist = 230;
        let val = dist / maxDist;
        if (val > 1) val = 1;
        if (val < 0) val = 0;

        state.expansion = val;
        radiusSlider.value = val * 100;
        if (radiusNumber) radiusNumber.value = Math.round(val * 100);
        update();
      });

      // Initial draw
      update();
    </script>
  </body>
</html>
